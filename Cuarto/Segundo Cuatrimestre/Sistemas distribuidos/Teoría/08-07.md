2 motivos por el cual hacer un sistema distribuido:

1. **Por diseño/definición es distribuido**
    
    Si yo quiero hacer un sistema de mensajería, por diseño va a ser distribuido.
    
    A este caso lo llamamos “**Descentralizado**”.
    
2. **No alcanza una sola computadora**
    
    Cuando el programa que corre no alcanza una sola computadora.
    
    A esto lo llamamos “**Distribuido**”
    

### Complejidad

> Los sistemas distribuidos son complejos

Algunos motivos son:

- Las computadoras se rompen
- No saben con quien comunicarse
- No se ponen de acuerdo
- Se corta la comunicación
- Se pierden los bits
- Pueden venir intrusos

Si yo no estoy constantemente monitoreandolo y asegurandome que funciona bien, pierdo confianza y no se usa mi producto.

## Objetivo funcional de un sistema distribuido

El objetivo fundamental es **compartir información**. La idea es ofrecer un recurso o proceso para que otros lo usen.

### Compartir recursos

Los recursos son cualquier cosa. Algunos ejemplos son:

- Archivos
- Mensajes
- Impresoras
- Servicios

### Transparencia en el acceso

Por ejemplo, como se va a mandar la información, cuales son los protocolos de comunicación, si se está encodeando. Toda esta información tiene que ser clara para facilitar la comunicación.

Para mejorar la transparencia, paradógicamente hay cosas que oculto. Pero ocultar alguna información y darla de una forma procesada ayuda a la comprensión del usuario. Yo a un usuario final no le voy a mostrar en que servidor estoy corriendo la aplicación.

### Apertura e interoperabilidad

Cuando yo adhiero a protocolos usados, estamos firmando un contrato que va a ayudar a la comunicación y la interoperabilidad. Un caso concreto es el uso de los jsons.

Significa hacer fácil al resto interactuar conmigo. Para hacer esto es importante entender quien quiero que interactúe conmigo.

### Confiabilidad

- **Disponibilidad**: cumplir con los niveles que yo digo que soporto. Yo puedo acotar el tiempo que digo que estoy disponible pero si o si tengo que cumplirlo.
- **Fiabilidad**: que porcentaje de ese tiempo que digo estoy realmente disponible.
- **Seguridad ante fallas**: que tan resistente a fallas es el sistema. El ejemplo de caos engineering de netflix, tirar servidores para poder funcionar bien igual.
- **Mantenibilidad**: actualizar el software no debería impactar en el servicio que le doy a la gente.

### Seguridad

La comunicación entre los cables es un llamado urgente a la seguridad, no queremos que gente intercepte la comunicación y saque información.

### Escalabilidad

Algunas dimensiones de la escalabilidad son:

- **Tamaño**: por ejemplo, la cantidad de usuario haciendo peticiones. También puede ser una sola persona descargando 4 petabytes de información.
- **Geografía**: si tenemos público de distintos lugares geográficos vamos a tener un montón de implicancia.
- **Administración**: hacer cambios se vuelve más complejo en recursos más grandes.

### Estrategias de escalamiento

- Mejorar la latencia, hacer que la comunicación sea más rápida.
- Si yo particiono puedo hacer que sea más sencillo acceder a la información y más rápido.
- Replicar es, en vez de separar la información en bloques, crear muchas veces la misma información.
- Caching, tener una sola fuente de información pero tener almacenamiento intermedio que sirve para los que me preguntan.

### Pausa

Vamos a estar teniendo constantemente tradeoffs para decidir que arquitectura llevamos a cabo. Por ejemplo, el tiempo de latencia viene dado por firewalls, switches, etc. Pero esto, al mismo tiempo es lo que nos brinda seguridad.

### Estilo arquitectonico

Nosotros tenemos una torta con muchas funcionalidades, la pregunta es: como vamos a dividir estas funcionalidades para que se comuniquen entre si? Donde hacemos el corte?

Algunos estilos definidos son:

- Por capas (Onion, modelo TCP)
- Orientada a servicios (cada uno ofrece algo)
- Pub/Sub

### Arquitectura orientada a servicios

Tenemos acoplamiento por referencia (sé quien sos) y temporal (tenemos que estar funcionando al mismo tiempo).

### Pub/sub

Diseño desacoplado

El productor del mensaje no necesita conocer a todos los destinatarios. Si los conociera implicaría acoplamiento.

### Middleware

Los wrappers y los interceptores implementan la interfaz que yo estoy llamando, realizan una llamada remota y luego me devuelve la respuesta. Este es un ejemplo claro de como ocultar información me trae transparencia. La diferencia entre wrappers e interceptores radica en el nivel. Wrapper es una clase, es de alto nivel mientras que interceptor está casi a nivel protocolo.

### Criterios de distribución

Vertical u horizontal. Cuando todos los nodos son iguales se llama “peer-to-peer” y medio que no importa como distribuyo porque pegarle a cualquiera va a hacer lo mismo. Si tengo distintas funcionalidades, tengo que ver como hago para separar.

# Procesos

## Threads

El uso de los threads en el sistema impacta mucho en la arquitectura que vayamos a hacer.