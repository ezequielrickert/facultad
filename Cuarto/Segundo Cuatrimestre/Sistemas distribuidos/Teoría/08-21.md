# Comunicación

El proceso tiene que compartir información con otros procesos. Es obvio que la comunicación es muy esencial. Si no podemos hacer que se comuniquen no tenemos sistemas distribuidos. El tipo de comunicación es una decisión de arquitectura, no es trivial. Está relacionado a costos y requerimientos no funcionales.

## Modelo OSI

Representación de como se maneja la comunicación, se espeja la emisión y la recepción. Cada capa le provee servicios a la capa siguiente.

Nosotros no usamos OSI, usamos TCP/IP. Esto se debe a:

- **Simplicidad**: tiene únicamente 4 capas.
- **Plata**: había intención de establecerlo como protocolo dominante, puesto por USA.

Las pocas implementaciones de OSI tuvieron muy poca adopción.

### Capa middleware - Tanenbaum

Son procesos que se paran en el medio del cual nos podemos olvidar. Por ejemplo, el DNS se encarga de darnos a nosotros, como usuarios, una capa de abstracción.

En comunicación tenemos una capa de middleware que va a hacer un montón de cosas transparente para nosotros. Provee capas de abstacción.

## RPC - Remote Procedure Call

Comunicación sincrónica, no necesariamente tiene que devolver valor, puede devolver un ACK. El chiste de RCP es tener un stub que sirve como interfaz para abstraer de la capa de comunicación.

### Marshalling

Tenemos que elegir un método en el cual vamos a encodear la comunicación. Ya que no corren con un mismo lenguaje, se tiene que permitir un sistema de codificación que permita la comunicación.

Si tenemos punteros y colección es un problema, porque tenemos que mandar toda la colección, no tiene ningún tipo de sentido mandar punteros ya que corren en máquinas distintas.

Lógicamente, esto trae un gran desafío que es enviar mucha información.

También es complejo si tenemos muchas colecciones anidadas y relacionadas.

No usamos JSON en las comunicaciones porque, si bien es muy simple, no es para nada eficiente. Nos resuelve el problema de enviar las colecciones pero tiene este problema de ser totalmente ineficiente.

Podemos usar referencias globales para solucionar el problema de colecciones grandes o anidadas sin comprometer la eficiencia.

### Referencias globales

Las referencias globales consisten en dejar las variables grandes y pesadas en una tercer máquina que se encarga de hacer las operaciones de transformación. De esta forma, entre las máquinas se comunican a traves de “punteros” o referencias de esa máquina. También, se puede hacer que esta máquina no tenga comunicación RCP eliminando el problema de enconding y mensajes.

En los mensajes, se tienen que poner de acuerdo las partes en como se va a encondear la información para los stubs.

RCP es parte del lenguaje, es por esto que si tenemos el mismo lenguaje en las máquinas, ya viene armado y esta disponible en la librería standard.

Cuando armamos la interfaz en el servidor, definimos que métodos, que información recibe o emite y en qué formato.

## Comunicación basada en mensajes

El mensaje es finito, es determinado. Se sabe que en algún momento se va a terminar y en general, tiene un formato conocido.

Son muy importantes cuando arrancamos a pensar en comunicación asincrónica.

ZeroMQ como evolución del socket (socket no es transparente). Si yo tengo P1 y P2, cada uno tiene su capa de 0MQ y se encarga de guardar su cola de mensajes si P2 no los recibe. De todos modos, 0MQ no tiene una herramienta de persistencia. Este es un claro ejemplo de comunicación asincrónica y transitoria, si se muere P1 y no llego a enviar data a P2, se pierde esa cola de mensajes.